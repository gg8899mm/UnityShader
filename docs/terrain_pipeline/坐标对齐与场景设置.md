# 坐标对齐与场景设置指南

## 概述

Web Mercator坐标系的正确处理是矿业数字孪生项目成功的关键。本指南详细说明：

1. **坐标系统基础** - 理解地理坐标与瓦片坐标
2. **Unity场景原点设置** - 降低浮点精度问题
3. **地形Tile拆分方案** - 优化Terrain性能
4. **坐标转换工具类** - 完整的转换代码
5. **对齐验证流程** - 确保数据准确

---

## 1. 坐标系统基础

### 1.1 三种坐标系

矿业数字孪生项目涉及三个坐标系的转换：

#### 坐标系统1：地理坐标 (经纬度)

```
格式：(Longitude, Latitude)
范围：Lon: [-180°, 180°], Lat: [-90°, 90°]
特点：基于球面，人类易理解
例：北京中心 (116.4074, 39.9042)
```

#### 坐标系统2：Web Mercator投影 (EPSG:3857)

```
格式：(X, Y) 单位：米
范围：X: [-20037508.34, 20037508.34]
      Y: [-20037508.34, 20037508.34]
投影：伪墨卡托投影（Google Maps标准）
特点：平面坐标，便于计算距离
例：北京中心 (12958175.3, 4885949.7)
```

#### 坐标系统3：XYZ瓦片坐标

```
格式：(X, Y, Z)
含义：Z = 缩放级别（14-20）
      X = 东西方向的瓦片列
      Y = 南北方向的瓦片行
特点：用于寻址瓦片文件
例：北京某瓦片 (131072, 87381, z17)
```

### 1.2 坐标转换公式

#### 经纬度 → Web Mercator

```
EARTH_RADIUS = 6378137.0  (地球半径，米)
PI = 3.14159265359

X = Longitude × PI × EARTH_RADIUS / 180
Y = ln(tan((90 + Latitude) × PI / 360)) × EARTH_RADIUS
```

**C#实现**：
```csharp
public class WebMercatorUtils
{
    private const double EarthRadius = 6378137.0;
    private const double MaxExtent = EarthRadius * Math.PI;

    public static (double x, double y) LonLatToMeters(double lon, double lat)
    {
        double x = lon * MaxExtent / 180.0;
        double y = Math.Log(Math.Tan((90.0 + lat) * Math.PI / 360.0)) 
                   * MaxExtent / Math.PI;
        return (x, y);
    }
}
```

#### Web Mercator → 经纬度

```
Longitude = X × 180 / (PI × EARTH_RADIUS)
Latitude = 2 × arctan(exp(Y / EARTH_RADIUS)) - 90°
```

**C#实现**：
```csharp
public static (double lon, double lat) MetersToLonLat(double x, double y)
{
    double lon = x * 180.0 / MaxExtent;
    double lat = 2.0 * Math.Atan(Math.Exp(y / EarthRadius)) * 180.0 / Math.PI - 90.0;
    return (lon, lat);
}
```

#### Web Mercator → 瓦片坐标

```
对于缩放级别 Z：
  tile_X = floor((X + MaxExtent) / (2 × MaxExtent / 2^Z))
  tile_Y = floor((MaxExtent - Y) / (2 × MaxExtent / 2^Z))
```

**C#实现**：
```csharp
public static (int x, int y) MetersToTile(double x, double y, int z)
{
    int tilesPerSide = 1 << z;  // 2^z
    double tileSize = (2.0 * MaxExtent) / tilesPerSide;
    
    int tileX = (int)Math.Floor((x + MaxExtent) / tileSize);
    int tileY = (int)Math.Floor((MaxExtent - y) / tileSize);
    
    // 边界处理
    tileX = Math.Max(0, Math.Min(tileX, tilesPerSide - 1));
    tileY = Math.Max(0, Math.Min(tileY, tilesPerSide - 1));
    
    return (tileX, tileY);
}
```

### 1.3 关键转换常数

```csharp
public static class WebMercatorConstants
{
    // 地球参数
    public const double EarthRadius = 6378137.0;
    public const double MaxExtent = EarthRadius * Math.PI;  // ~20037508.34
    
    // 瓦片参数
    public const int TileSize = 512;  // 像素
    public const int MinZoom = 14;
    public const int MaxZoom = 20;
    
    // 计算方便常数
    public static double MetersPerPixel(int zoom)
    {
        return (2.0 * MaxExtent) / (Math.Pow(2, zoom) * TileSize);
    }
}
```

---

## 2. Unity场景原点设置

### 2.1 为什么要设置场景原点？

**问题**：

矿区范围约42×48km，在Web Mercator坐标中的实际值为：
```
X: 12000000 到 12042000 (单位：米)
Y: 3500000 到 3548000 (单位：米)
```

直接将这些坐标用作Unity world position会导致：
- 浮点精度问题（坐标过大）
- 物理引擎失效（距离变小）
- 光影计算错误（深度精度丧失）

**解决方案**：

选择矿区中心作为Unity原点(0, 0, 0)，所有其他坐标相对此原点计算。

### 2.2 计算场景原点

#### 步骤A：确定矿区中心坐标

方案1：从QGIS获取
```
打开QGIS
鼠标移到矿区中心，查看坐标显示
记录 Web Mercator 坐标
```

方案2：从经纬度计算
```
已知：矿区中心经纬度 (Lon, Lat)
使用转换函数计算：
(centerX, centerY) = LonLatToMeters(Lon, Lat)
```

#### 步骤B：设置Unity原点

```csharp
public class SceneOriginManager : MonoBehaviour
{
    // 矿区中心的Web Mercator坐标（单位：米）
    private Vector2 _sceneOriginMeters = new Vector2(12021000, 3524000);
    
    // 对应的经纬度（用于参考）
    private Vector2 _sceneOriginLonLat = new Vector2(108.05, 31.85);
    
    private void Start()
    {
        Debug.Log($"Scene Origin (Meters): {_sceneOriginMeters}");
        Debug.Log($"Scene Origin (LonLat): {_sceneOriginLonLat}");
    }
    
    // 获取场景原点
    public Vector2 GetOriginMeters() => _sceneOriginMeters;
    public Vector2 GetOriginLonLat() => _sceneOriginLonLat;
}
```

#### 步骤C：验证原点

在QGIS和Unity中对比：

```
QGIS中读取的坐标值（Web Mercator）
       ↓
减去 SceneOrigin（12021000, 3524000）
       ↓
得到 Unity相对坐标
       ↓
Unity中的world position应该相等
```

示例：
```
某个建筑物在QGIS中的Web Mercator坐标：(12021100, 3524100)
减去场景原点：(12021100 - 12021000, 3524100 - 3524000) = (100, 100)
在Unity中应放置于：Position (100, ?, 100)
  其中 Y 由地形高度决定
```

### 2.3 坐标转换工具类

创建`WebMercatorSceneUtils.cs`：

```csharp
using UnityEngine;
using System;

namespace TileStreaming
{
    /// <summary>
    /// Web Mercator坐标与Unity Scene坐标转换工具
    /// </summary>
    public class WebMercatorSceneUtils
    {
        private const double EarthRadius = 6378137.0;
        private const double MaxExtent = EarthRadius * Math.PI;
        private const int TileSize = 512;

        private Vector2 _sceneOriginMeters;
        private Vector2 _sceneOriginLonLat;

        public WebMercatorSceneUtils(Vector2 originMeters, Vector2 originLonLat)
        {
            _sceneOriginMeters = originMeters;
            _sceneOriginLonLat = originLonLat;
        }

        // ==================== 坐标转换方法 ====================

        /// <summary>
        /// 经纬度 → Web Mercator投影坐标
        /// </summary>
        public static (double x, double y) LonLatToMeters(double lon, double lat)
        {
            double x = lon * MaxExtent / 180.0;
            double y = Math.Log(Math.Tan((90.0 + lat) * Math.PI / 360.0)) * MaxExtent / Math.PI;
            return (x, y);
        }

        /// <summary>
        /// Web Mercator投影坐标 → 经纬度
        /// </summary>
        public static (double lon, double lat) MetersToLonLat(double x, double y)
        {
            double lon = x * 180.0 / MaxExtent;
            double lat = 2.0 * Math.Atan(Math.Exp(y / EarthRadius)) * 180.0 / Math.PI - 90.0;
            return (lon, lat);
        }

        /// <summary>
        /// Web Mercator坐标 → XYZ瓦片坐标
        /// </summary>
        public static (int tileX, int tileY) MetersToTile(double x, double y, int z)
        {
            int tilesPerSide = 1 << z;
            double tileSize = (2.0 * MaxExtent) / tilesPerSide;

            int tileX = (int)Math.Floor((x + MaxExtent) / tileSize);
            int tileY = (int)Math.Floor((MaxExtent - y) / tileSize);

            tileX = Math.Max(0, Math.Min(tileX, tilesPerSide - 1));
            tileY = Math.Max(0, Math.Min(tileY, tilesPerSide - 1));

            return (tileX, tileY);
        }

        /// <summary>
        /// XYZ瓦片坐标 → Web Mercator边界框（单位：米）
        /// </summary>
        public static (double minX, double maxX, double minY, double maxY) TileBounds(
            int tileX, int tileY, int z)
        {
            int tilesPerSide = 1 << z;
            double tileSize = (2.0 * MaxExtent) / tilesPerSide;

            double minX = tileX * tileSize - MaxExtent;
            double maxX = (tileX + 1) * tileSize - MaxExtent;
            double maxY = MaxExtent - tileY * tileSize;
            double minY = MaxExtent - (tileY + 1) * tileSize;

            return (minX, maxX, minY, maxY);
        }

        // ==================== Scene相对坐标转换 ====================

        /// <summary>
        /// Web Mercator坐标 → Unity Scene相对坐标
        /// 结果可直接用作 transform.position 的 x, z 分量
        /// </summary>
        public Vector3 MetersToUnityLocal(double x, double y, float heightY = 0f)
        {
            float localX = (float)(x - _sceneOriginMeters.x);
            float localZ = (float)(y - _sceneOriginMeters.y);
            return new Vector3(localX, heightY, localZ);
        }

        /// <summary>
        /// 经纬度 → Unity Scene相对坐标
        /// </summary>
        public Vector3 LonLatToUnityLocal(double lon, double lat, float heightY = 0f)
        {
            var (x, y) = LonLatToMeters(lon, lat);
            return MetersToUnityLocal(x, y, heightY);
        }

        /// <summary>
        /// Unity Scene相对坐标 → Web Mercator坐标
        /// </summary>
        public (double x, double y) UnityLocalToMeters(Vector3 unityPos)
        {
            double x = unityPos.x + _sceneOriginMeters.x;
            double y = unityPos.z + _sceneOriginMeters.y;
            return (x, y);
        }

        /// <summary>
        /// Unity Scene相对坐标 → 经纬度
        /// </summary>
        public (double lon, double lat) UnityLocalToLonLat(Vector3 unityPos)
        {
            var (x, y) = UnityLocalToMeters(unityPos);
            return MetersToLonLat(x, y);
        }

        // ==================== 瓦片查询 ====================

        /// <summary>
        /// 获取Unity坐标所在的瓦片
        /// </summary>
        public TileCoord GetTileAtUnityPosition(Vector3 unityPos, int z)
        {
            var (x, y) = UnityLocalToMeters(unityPos);
            var (tileX, tileY) = MetersToTile(x, y, z);
            return new TileCoord(tileX, tileY, z);
        }

        /// <summary>
        /// 获取瓦片在Unity坐标系中的四角坐标
        /// 返回：(西南角, 西北角, 东南角, 东北角)
        /// </summary>
        public (Vector3, Vector3, Vector3, Vector3) GetTileQuadUnityCoords(
            int tileX, int tileY, int z)
        {
            var (minX, maxX, minY, maxY) = TileBounds(tileX, tileY, z);

            // Web Mercator: Y轴向上为北
            // 但需转换为Unity坐标系统（X-Z平面）
            Vector3 sw = MetersToUnityLocal(minX, minY);
            Vector3 nw = MetersToUnityLocal(minX, maxY);
            Vector3 se = MetersToUnityLocal(maxX, minY);
            Vector3 ne = MetersToUnityLocal(maxX, maxY);

            return (sw, nw, se, ne);
        }

        /// <summary>
        /// 计算两点间的地面距离（米）
        /// </summary>
        public double DistanceBetweenMeters(double x1, double y1, double x2, double y2)
        {
            return Math.Sqrt(Math.Pow(x2 - x1, 2) + Math.Pow(y2 - y1, 2));
        }

        /// <summary>
        /// 计算某缩放级别下的地面分辨率（米/像素）
        /// </summary>
        public static double MetersPerPixel(int zoom)
        {
            return (2.0 * MaxExtent) / (Math.Pow(2, zoom) * TileSize);
        }
    }
}
```

---

## 3. 地形Tile拆分方案

### 3.1 问题与对策

**Unity Terrain限制**：

```
单个TerrainData的最大分辨率: 2049×2049
实际可用高度图: 2048×2048
对应地面大小: 取决于 terrain_scale
```

**方案**：

将42×48km矿区拆分为多个2km×2km的地形块，使用**21×24网格**。

### 3.2 地形Tile拆分计算

```
矿区总范围: 42km × 48km
单个Terrain块: 2km × 2km
拆分网格: 21(西-东) × 24(南-北) = 504个Terrain块

优势：
- 单个Terrain块尺寸合理（2km×2km）
- 网格数量可管理（504个）
- 支持LOD流式加载
```

### 3.3 计算单个Terrain块的参数

```csharp
public class TerrainTileManager
{
    private const int TilesWest = 21;      // X方向tile数
    private const int TilesSouth = 24;     // Z方向tile数
    private const float TerrainSize = 2000f;  // 单个tile大小（米）
    
    private const int HeightmapResolution = 2048;  // Terrain高度图分辨率
    
    // 单位分辨率：每像素对应多少米
    private const float HeightmapScale = TerrainSize / HeightmapResolution;
    // = 2000 / 2048 ≈ 0.977 米/像素
    
    /// <summary>
    /// 获取某个Terrain块的西南角(世界坐标)
    /// </summary>
    public Vector3 GetTerrainTilePosition(int tileX, int tileZ)
    {
        float worldX = tileX * TerrainSize;
        float worldZ = tileZ * TerrainSize;
        return new Vector3(worldX, 0, worldZ);
    }
    
    /// <summary>
    /// 获取某个Terrain块对应的瓦片坐标范围(z18)
    /// 用于确定该Terrain块需要加载哪些卫星影像瓦片
    /// </summary>
    public (int minTileX, int maxTileX, int minTileY, int maxTileY) 
        GetTerrainTileCoverage(int terrainTileX, int terrainTileZ, 
        WebMercatorSceneUtils mercator)
    {
        // 获取Terrain块的四角坐标
        Vector3 sw = GetTerrainTilePosition(terrainTileX, terrainTileZ);
        Vector3 ne = GetTerrainTilePosition(terrainTileX + 1, terrainTileZ + 1);
        
        // 转换为Web Mercator坐标
        var (x1, y1) = mercator.UnityLocalToMeters(sw);
        var (x2, y2) = mercator.UnityLocalToMeters(ne);
        
        // 查询z18级别的瓦片
        var (tileX1, tileY1) = WebMercatorSceneUtils.MetersToTile(x1, y1, 18);
        var (tileX2, tileY2) = WebMercatorSceneUtils.MetersToTile(x2, y2, 18);
        
        return (
            System.Math.Min(tileX1, tileX2),
            System.Math.Max(tileX1, tileX2),
            System.Math.Min(tileY1, tileY2),
            System.Math.Max(tileY1, tileY2)
        );
    }
}
```

### 3.4 Terrain创建脚本

```csharp
using UnityEngine;

public class TerrainGenerator : MonoBehaviour
{
    [SerializeField] private int terrainResolution = 2048;
    [SerializeField] private float heightScale = 1.0f;
    [SerializeField] private Material terrainMaterial;

    public void GenerateTerrainGrid()
    {
        const int tilesWest = 21;
        const int tilesSouth = 24;
        const float tileSize = 2000f;

        for (int x = 0; x < tilesWest; x++)
        {
            for (int z = 0; z < tilesSouth; z++)
            {
                CreateTerrainTile(x, z, tileSize);
            }
        }
    }

    private void CreateTerrainTile(int tileX, int tileZ, float size)
    {
        // 创建TerrainData
        TerrainData terrainData = new TerrainData();
        terrainData.heightmapResolution = terrainResolution;
        terrainData.size = new Vector3(size, 300f, size);

        // 初始化高度图（平坦）
        int resolution = terrainData.heightmapResolution;
        float[,] heights = new float[resolution, resolution];
        for (int i = 0; i < resolution; i++)
        {
            for (int j = 0; j < resolution; j++)
            {
                heights[i, j] = 0.5f;  // 中间高度
            }
        }
        terrainData.SetHeights(0, 0, heights);

        // 创建Terrain GameObject
        GameObject terrainGO = Terrain.CreateTerrainGameObject(terrainData);
        terrainGO.name = $"Terrain_X{tileX}_Z{tileZ}";
        terrainGO.transform.position = new Vector3(
            tileX * size,
            0,
            tileZ * size
        );

        // 设置材质
        if (terrainMaterial != null)
        {
            Terrain terrain = terrainGO.GetComponent<Terrain>();
            terrain.materialTemplate = terrainMaterial;
        }
    }
}
```

---

## 4. 贴图与地形对齐

### 4.1 核心对齐策略

瓦片System提供了卫星影像纹理，但需要确保：

1. **水平对齐**：纹理坐标与地形网格坐标相同
2. **高度对齐**：移除视差（texture parallax）

### 4.2 使用Terrain.SampleHeight()消除视差

```csharp
using UnityEngine;
using TileStreaming;

public class TerrainTextureAligner : MonoBehaviour
{
    private Terrain[] _terrains;
    private WebMercatorSceneUtils _mercator;

    private void Start()
    {
        _terrains = FindObjectsOfType<Terrain>();
        
        // 初始化Mercator工具
        _mercator = new WebMercatorSceneUtils(
            originMeters: new Vector2(12021000, 3524000),
            originLonLat: new Vector2(108.05, 31.85)
        );
    }

    /// <summary>
    /// 为瓦片Quad网格应用高度贴图
    /// 消除纹理与地形的高度差异
    /// </summary>
    public void AlignTextureToTerrain(
        GameObject quadGameObject,
        int tileX, int tileY, int tileZ)
    {
        // 获取瓦片的四个角坐标
        var (sw, nw, se, ne) = _mercator.GetTileQuadUnityCoords(tileX, tileY, tileZ);

        // 采样地形高度
        float swHeight = SampleTerrainHeight(sw);
        float nwHeight = SampleTerrainHeight(nw);
        float seHeight = SampleTerrainHeight(se);
        float neHeight = SampleTerrainHeight(ne);

        // 更新Quad顶点（消除视差）
        MeshFilter meshFilter = quadGameObject.GetComponent<MeshFilter>();
        if (meshFilter != null)
        {
            UpdateMeshHeights(
                meshFilter.mesh,
                new[] { swHeight, nwHeight, seHeight, neHeight }
            );
        }
    }

    private float SampleTerrainHeight(Vector3 worldPos)
    {
        foreach (Terrain terrain in _terrains)
        {
            if (terrain.GetComponent<TerrainCollider>() != null)
            {
                float height = terrain.SampleHeight(worldPos);
                if (height > 0)
                    return worldPos.y + height;
            }
        }

        // 未采样到高度，返回默认高度
        return 0f;
    }

    private void UpdateMeshHeights(Mesh mesh, float[] heights)
    {
        Vector3[] vertices = mesh.vertices;

        // 假设Quad由4个顶点组成
        // 顺序：SW, NW, SE, NE
        if (vertices.Length >= 4)
        {
            vertices[0].y = heights[0];  // SW
            vertices[1].y = heights[1];  // NW
            vertices[2].y = heights[2];  // SE
            vertices[3].y = heights[3];  // NE
        }

        mesh.vertices = vertices;
        mesh.RecalculateNormals();
    }
}
```

### 4.3 浮点精度最佳实践

```csharp
public class PrecisionBestPractices
{
    // ✓ 推荐：使用相对于场景原点的坐标
    void CorrectWay()
    {
        // 场景原点已设置为矿区中心
        Vector3 scenePosition = new Vector3(100f, 50f, 200f);
        // X, Z为相对Web Mercator的偏移（小数值）
        // 精度损失最小
    }

    // ✗ 不推荐：直接使用Web Mercator绝对坐标
    void IncorrectWay()
    {
        Vector3 worldPosition = new Vector3(12021100f, 100f, 3524100f);
        // 坐标值极大，浮点精度低
        // 可能导致：物体颤动、物理计算错误
    }

    // ✓ 推荐：分离世界坐标和渲染坐标
    public class CameraPosSystem
    {
        private Vector3 _cameraWorldPos;  // 完整世界坐标
        private Vector3 _cameraRenderPos; // 相对于场景原点的渲染坐标

        public void UpdateCameraPosition(Vector3 newWorldPos)
        {
            _cameraWorldPos = newWorldPos;
            
            // 计算相对于场景原点的坐标
            _cameraRenderPos = newWorldPos - GetSceneOrigin();
            
            // 仅使用 _cameraRenderPos 用于渲染
            Camera.main.transform.position = _cameraRenderPos;
        }

        private Vector3 GetSceneOrigin()
        {
            return new Vector3(12021000f, 0f, 3524000f);
        }
    }
}
```

---

## 5. 验证流程

### 5.1 坐标对齐检查清单

```
□ 第1步：场景原点设置
  □ 已记录矿区中心Web Mercator坐标
  □ 在SceneOriginManager中配置
  □ Debug.Log验证输出正确

□ 第2步：坐标转换验证
  □ 创建简单测试场景
  □ 放置几个已知地理位置的标记物
  □ 验证Unity位置与地理位置对应

□ 第3步：瓦片加载验证
  □ 加载单个瓦片
  □ 在QGIS和Unity中对比位置
  □ 检查是否有偏移或翻转

□ 第4步：地形对齐验证
  □ 创建测试Terrain块
  □ 加载对应的卫星影像瓦片
  □ 视觉检查对齐情况
  □ 使用Gizmos绘制参考线辅助判断
```

### 5.2 验证脚本

```csharp
using UnityEngine;
using TileStreaming;

public class CoordinateVerifier : MonoBehaviour
{
    [SerializeField] private WebMercatorSceneUtils _mercator;
    [SerializeField] private double _testLon = 108.05;
    [SerializeField] private double _testLat = 31.85;

    private void OnGUI()
    {
        GUILayout.BeginArea(new Rect(10, 10, 400, 300));
        
        // 显示场景原点
        GUILayout.Label("=== 坐标系统验证 ===");
        
        // 转换测试
        var (x, y) = WebMercatorSceneUtils.LonLatToMeters(_testLon, _testLat);
        GUILayout.Label($"LonLat ({_testLon}, {_testLat})");
        GUILayout.Label($"→ Meters ({x:F2}, {y:F2})");

        // Tile查询
        var (tileX, tileY) = WebMercatorSceneUtils.MetersToTile(x, y, 18);
        GUILayout.Label($"→ Tile z18: ({tileX}, {tileY})");

        // 相对坐标
        Vector3 localPos = _mercator.LonLatToUnityLocal(_testLon, _testLat);
        GUILayout.Label($"→ Unity Local: ({localPos.x:F2}, {localPos.z:F2})");

        GUILayout.EndArea();
    }

    private void OnDrawGizmos()
    {
        if (_mercator == null)
            return;

        // 绘制场景原点
        Vector3 origin = Vector3.zero;
        Gizmos.color = Color.red;
        Gizmos.DrawSphere(origin, 10f);
        Gizmos.DrawLine(origin, origin + Vector3.right * 100f);
        Gizmos.DrawLine(origin, origin + Vector3.forward * 100f);
    }
}
```

### 5.3 常见对齐问题

| 问题 | 症状 | 解决方案 |
|-----|-----|--------|
| **Y轴翻转** | 瓦片上下颠倒 | 检查TMS vs XYZ设置（见QGIS_工作流.md） |
| **水平平移** | 瓦片偏离实际位置 | 验证SceneOrigin设置，重新计算Web Mercator坐标 |
| **浮点误差** | 物体抖动/精度丧失 | 使用相对坐标，设置场景原点 |
| **地形高度不匹配** | 纹理与地形高度不同 | 使用Terrain.SampleHeight()校准 |

---

## 6. 快速参考表

### 缩放级别覆盖范围

```
Z级   理论覆盖(km×km)   建议用途          建议地形块大小
14    ~2700×2700      全球概览          10km×10km
15    ~1350×1350      大陆尺度          5km×5km
16    ~670×670        国家尺度          2-3km×2-3km
17    ~335×335        地区尺度          1-2km×1-2km
18    ~168×168        城市尺度          500m×500m ← 基础层上限
19    ~84×84          街区尺度          250m×250m ← ROI层
20    ~42×42          建筑尺度          125m×125m ← ROI高精度
```

### 坐标转换速查

```
操作                           相关函数
─────────────────────────────────────────────────────
输入：经纬度 → 输出：地形位置   LonLatToUnityLocal()
输入：地形位置 → 输出：经纬度   UnityLocalToLonLat()
输入：地形位置 → 输出：瓦片     GetTileAtUnityPosition()
输入：瓦片 → 输出：地形四角    GetTileQuadUnityCoords()
两点间距离计算                DistanceBetweenMeters()
```

---

## 参考资源

- **Web Mercator维基百科**：https://en.wikipedia.org/wiki/Web_Mercator_projection
- **EPSG:3857参考**：https://epsg.io/3857
- **XYZ瓦片系统**：https://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
- **Unity Terrain文档**：https://docs.unity3d.com/Manual/terrain-UsingTerrains.html
