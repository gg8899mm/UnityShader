# 性能优化检查清单

## 概述

本文档提供矿业数字孪生项目的性能优化策略，包括纹理流式处理、显存预算、LOD参数调优、并发加载优化等。

---

## 1. 纹理流式处理

### 1.1 启用Texture Streaming

Texture Streaming是Unity的内置功能，能根据相机距离自动降低远处纹理的分辨率。

1. **打开Player Settings**
   - Edit → Project Settings → Player

2. **找到Quality标签页**
   - 搜索框输入"streaming"

3. **启用Stream Textures**
   ```
   ☑ Streaming Textures
   Pool Size: 512 MB  (根据显存调整)
   ```

### 1.2 配置Texture Streaming参数

```
┌─ Texture Streaming ────────────────┐
│                                   │
│ ☑ Stream Textures                 │ ← 必须启用
│ ☑ Stream Textures when Visible    │ ← 默认建议
│ Pool Size: 512 MB                 │ ← GPU显存池
│ ☑ Global Budget: 512 MB           │ ← 全局预算
│ ☑ Max Streaming Mips: 16          │ ← MipMap级数
│                                   │
└───────────────────────────────────┘
```

### 1.3 最佳实践

```csharp
// 在场景启动时配置
public class TextureStreamingConfig : MonoBehaviour
{
    private void Start()
    {
        // 打印当前Texture Streaming状态
        Debug.Log($"Texture Streaming Enabled: " +
                  $"{QualitySettings.streamingMipmapsActive}");
        
        Debug.Log($"Texture Streaming Pool Size: " +
                  $"{QualitySettings.streamingMipmapsMemoryBudget} MB");
    }
}
```

---

## 2. 显存预算管理

### 2.1 计算每个瓦片的显存占用

```
PNG格式 (512×512):
  未压缩大小 = 512 × 512 × 4字节 (RGBA32) = 1 MB
  
  但实际被压缩存储到显存：
  - 如启用显存压缩 (DXT/BC): 256-512 KB
  - 默认情况: 512-1024 KB

KTX2格式 (512×512):
  ETC1S压缩: 200-400 KB
  UASTC压缩: 400-600 KB
```

### 2.2 根据硬件确定缓存预算

```
| GPU显存 | 缓存预算 | 最多瓦片数 | 推荐场景 |
|--------|--------|---------|--------|
| 2 GB   | 64-128 MB | 64-128 | 移动/低端PC |
| 4 GB   | 256-512 MB | 256-512 | 标准PC |
| 6-8 GB | 512-1024 MB | 512-1024 | 高端工作站 |
| 12 GB+ | 2-4 GB | 2000-4000 | 专业VR/实时渲染 |
```

### 2.3 在代码中管理显存

```csharp
public class GPUMemoryManager : MonoBehaviour
{
    [SerializeField] private long _cacheMemoryMB = 512;
    private TileStreamer _tileStreamer;

    private void Start()
    {
        _tileStreamer = GetComponent<TileStreamer>();
        _tileStreamer.SetCacheMemoryMB(_cacheMemoryMB);
        
        // 监控显存使用
        InvokeRepeating(nameof(MonitorMemory), 1f, 1f);
    }

    private void MonitorMemory()
    {
        var (count, usedMB, budgetMB) = _tileStreamer.GetCacheStats();
        
        float usageRatio = (float)usedMB / budgetMB;
        
        // 显存使用超过90%时警告
        if (usageRatio > 0.9f)
        {
            Debug.LogWarning($"GPU Memory high: {usageRatio * 100:F1}% " +
                           $"({usedMB}MB / {budgetMB}MB)");
            
            // 可选：动态增加缓存
            if (budgetMB < 2048)
            {
                _tileStreamer.SetCacheMemoryMB(budgetMB * 2);
                Debug.Log($"Increased cache to {budgetMB * 2}MB");
            }
        }
    }
}
```

### 2.4 显存优化技巧

```csharp
// 1. 启用纹理压缩（Editor中）
public void OptimizeTextureImport()
{
    // Assets中的瓦片纹理应设置为：
    // - Compression: Normal Quality
    // - Format: Compressed (DXT)
    // - CRUNCH compression: 启用（减少50-60%）
}

// 2. 动态卸载不可见瓦片
public void UnloadInvisibleTiles(Camera camera)
{
    // Tile Streamer的LRU缓存会自动处理
    // 但可以手动清除特定ROI：
    
    // _tileStreamer.ClearCache();
    // 完全清除（谨慎使用）
}

// 3. 减少MipMap级别
// 在Shader或Material设置中
private void SetupMaterialMipmaps(Material mat)
{
    // Texture使用Max Level限制MipMap深度
    // 减少显存而不影响清晰度
}
```

---

## 3. LOD参数调优

### 3.1 理解LOD距离

```
相机距离决定加载的LOD级别：

距离(米)     推荐LOD    用途
────────────────────────
0-5,000     z20       近景细节（单个建筑）
5,000-20,000  z19     中景（建筑群）
20,000-50,000 z18     远景（整个矿区）
50,000+     z14-17    全局概览
```

### 3.2 调整加载范围

```csharp
public class LODController : MonoBehaviour
{
    [SerializeField] private int nearZoom = 20;
    [SerializeField] private int nearRadius = 2;
    [SerializeField] private int midZoom = 19;
    [SerializeField] private int midRadius = 4;
    [SerializeField] private int farZoom = 18;
    [SerializeField] private int farRadius = 8;

    // 根据帧率动态调整
    private void Update()
    {
        float fps = 1f / Time.deltaTime;
        
        if (fps < 30f)
        {
            // 性能不足，减少加载
            nearRadius = 1;
            midRadius = 2;
            farRadius = 4;
        }
        else if (fps > 60f)
        {
            // 性能充足，增加细节
            nearRadius = 3;
            midRadius = 5;
            farRadius = 10;
        }
    }
}
```

### 3.3 性能影响分析

```
加载范围 vs 性能权衡表：

加载参数                 内存占用  IO带宽  帧率影响
──────────────────────────────────────────
Z20 nearRadius=1       低      低      高(60+ FPS)
Z20 nearRadius=2       低→中   中      中(45-60 FPS)
Z20 nearRadius=3       中      高      低(30-45 FPS)
Z20 nearRadius=4+      高      很高    卡顿(<30 FPS)

建议：
- 低端硬件: Z19-Z20, radius=1
- 标准硬件: Z18-Z20, radius=2-3
- 高端硬件: Z17-Z20, radius=3-4
```

---

## 4. 并发加载限制

### 4.1 概念说明

```
并发加载数 = 同时加载的瓦片数量

过低(<2):    加载缓慢
适中(4-8):   平衡速度和稳定性
过高(>8):    内存/网络压力大，可能卡顿
```

### 4.2 根据硬件调整

```csharp
public class ConcurrentLoadConfig
{
    public static int GetOptimalConcurrentLoads()
    {
        // 检测CPU核心数
        int cpuCores = SystemInfo.processorCount;
        
        // 检测磁盘类型（相对值）
        // 实际需要运行时判断
        bool isSSD = DetectSSD();
        
        if (cpuCores <= 2)
            return 2;  // 低端
        else if (cpuCores <= 4)
            return isSSD ? 4 : 2;  // 中端
        else if (cpuCores <= 8)
            return isSSD ? 8 : 4;  // 高端
        else
            return isSSD ? 16 : 8;  // 超高端
    }

    private static bool DetectSSD()
    {
        // 简单检测：尝试快速IO
        // 真实项目中应使用更精确的方法
        return true;  // 假设最新硬件
    }
}
```

### 4.3 性能监控

```csharp
public class LoadPerformanceMonitor : MonoBehaviour
{
    private TileStreamer _tileStreamer;
    private Queue<float> _frameTimeHistory;
    private const int HistorySize = 60;

    private void Start()
    {
        _frameTimeHistory = new Queue<float>(HistorySize);
        InvokeRepeating(nameof(CheckLoadPerformance), 1f, 1f);
    }

    private void Update()
    {
        _frameTimeHistory.Enqueue(Time.deltaTime);
        if (_frameTimeHistory.Count > HistorySize)
            _frameTimeHistory.Dequeue();
    }

    private void CheckLoadPerformance()
    {
        float avgFrameTime = 0f;
        foreach (float time in _frameTimeHistory)
            avgFrameTime += time;
        avgFrameTime /= _frameTimeHistory.Count;

        float avgFPS = 1f / avgFrameTime;

        var (count, usedMB, budgetMB) = _tileStreamer.GetCacheStats();

        Debug.Log($"Performance Report:\n" +
                 $"  FPS: {avgFPS:F1}\n" +
                 $"  Frame Time: {avgFrameTime * 1000:F1}ms\n" +
                 $"  Tiles Loaded: {count}\n" +
                 $"  Memory: {usedMB}MB / {budgetMB}MB");

        // 根据性能自动调整
        if (avgFPS < 30f)
            Debug.LogWarning("Performance below 30 FPS!");
    }
}
```

---

## 5. KTX2压缩选项对比

### 5.1 两种压缩模式

#### 模式A：ETC1S压缩（推荐）

```
命令: toktx --t2 --bcmp --genmipmap output.ktx2 input.png

优点:
  - 文件最小(原大小的30-40%)
  - 跨平台兼容性强
  - 加载速度快
  - 显存占用小

缺点:
  - 质量下降(肉眼难以察觉)
  - 某些高对比场景会有色晕

应用场景:
  - 基础瓦片(z14-z18)
  - 流式加载场景
  - 移动端或显存受限环境
```

#### 模式B：UASTC压缩（高质量）

```
命令: toktx --t2 --uastc --genmipmap output.ktx2 input.png

优点:
  - 质量更好(接近原始PNG)
  - 适合极高细节需求
  - 某些硬件加速更好

缺点:
  - 文件较大(原大小的50-70%)
  - 加载速度较慢
  - 显存占用多

应用场景:
  - 建筑群近景(z20)
  - 高端渲染
  - 质量优先场景
```

### 5.2 混合策略（推荐）

```csharp
public class HybridCompressionStrategy
{
    public static string GetCompressionMode(int zoomLevel)
    {
        if (zoomLevel <= 18)
            return "bcmp";      // ETC1S - 文件小
        else if (zoomLevel == 19)
            return "bcmp";      // 折衷方案
        else // zoomLevel == 20
            return "uastc";     // UASTC - 质量高
    }
}

// 转换脚本示例
/*
foreach tile in tiles_base (z14-z18):
    toktx --t2 --bcmp --genmipmap output.ktx2 input.png

foreach tile in tiles_roi_* (z19-z20):
    toktx --t2 --bcmp --genmipmap output.ktx2 input.png  (z19)
    toktx --t2 --uastc --genmipmap output.ktx2 input.png (z20)
*/
```

### 5.3 文件大小预估

```
| 数据集 | 格式 | 文件数 | 总大小(原PNG) | 转KTX2后 | 节省 |
|-------|-----|-------|-------------|---------|-----|
| 基础瓦片(z14-z18) | PNG | 680 | 400 MB | PNG | 0% |
| " | KTX2(bcmp) | 680 | 400 MB | 120 MB | 70% |
| ROI×7(z19-z20) | PNG | 2100 | 1200 MB | 1200 MB | 0% |
| " | KTX2(bcmp) | 2100 | 1200 MB | 360 MB | 70% |
| 总计 | PNG | 2780 | 1600 MB | 1600 MB | 0% |
| " | KTX2(混合) | 2780 | 1600 MB | 500 MB | 69% |

结论：转KTX2可节省约70%的磁盘/显存空间
```

---

## 6. Profiler使用指南

### 6.1 开启Profiler

```
Window → Analysis → Profiler
快捷键: Ctrl+7
```

### 6.2 重点监控指标

#### CPU性能

```
Memory标签:
  - Managed Heap: 脚本内存占用
  - GfxDriver: 图形驱动内存
  
推荐: <200 MB
```

#### GPU性能

```
GPU标签:
  - Vertices: 三角形数量
  - Draw Calls: 渲染调用次数
  
推荐: 
  - Vertices: <1M
  - Draw Calls: <100
```

#### 纹理内存

```
Memory标签 → Textures分类:
  当前总大小: 应<缓存预算的80%
  
推荐:
  - 低端: <64 MB
  - 中端: <256 MB
  - 高端: <1024 MB
```

### 6.3 性能基准参考

```
阶段1（单ROI测试）
  目标硬件: 标准PC (GTX 1060, i5-8400)
  预期帧率: 60+ FPS
  显存占用: <256 MB
  CPU占用: <20%
  
阶段2（多ROI扩展）
  相同硬件
  预期帧率: 45-60 FPS
  显存占用: <512 MB
  CPU占用: <30%
  
阶段3（全域加载）
  相同硬件
  预期帧率: 30+ FPS
  显存占用: 512-1024 MB
  CPU占用: 40-50%
```

### 6.4 使用脚本监控

```csharp
using UnityEngine;
using UnityEngine.Profiling;

public class ProfilerLogger : MonoBehaviour
{
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.P))
        {
            LogProfilerStats();
        }
    }

    private void LogProfilerStats()
    {
        long totalMemory = Profiler.GetTotalMemoryUsed() / 1024 / 1024;
        long monoMemory = Profiler.GetMonoUsedSizeLong() / 1024 / 1024;
        long gpuMemory = Profiler.GetTotalReservedMemory() / 1024 / 1024;

        Debug.Log($"=== Profiler Stats ===\n" +
                 $"Total Memory: {totalMemory} MB\n" +
                 $"Mono Memory: {monoMemory} MB\n" +
                 $"GPU Memory: {gpuMemory} MB\n" +
                 $"Frame Time: {Time.deltaTime * 1000:F1} ms\n" +
                 $"FPS: {1f / Time.deltaTime:F1}");
    }
}
```

---

## 7. 常见性能问题排查

### 7.1 帧率突降

| 症状 | 原因 | 解决方案 |
|-----|-----|--------|
| 周期性卡顿 | 垃圾回收(GC) | 预分配对象池；减少瓦片数 |
| 移动时卡顿 | 瓦片加载阻塞 | 增加`Max Concurrent Loads`；使用KTX2 |
| 特定位置卡顿 | ROI转换开销 | 预加载；使用MultiROIProvider |
| 持续低帧率 | 显存溢出 | 减少`Cache Memory MB`；降低LOD |

### 7.2 显存溢出

```csharp
// 监测显存溢出
public class OutOfMemoryDetector : MonoBehaviour
{
    private TileStreamer _tileStreamer;

    private void Update()
    {
        try
        {
            var (count, usedMB, budgetMB) = _tileStreamer.GetCacheStats();
            
            if (usedMB > budgetMB * 0.95f)
            {
                // 主动清空一些瓦片
                Debug.LogWarning("Cache near full, clearing oldest tiles...");
                // 或者动态增加预算
                _tileStreamer.SetCacheMemoryMB(budgetMB * 1.5);
            }
        }
        catch (OutOfMemoryException)
        {
            Debug.LogError("Out of memory! Clearing all tiles.");
            _tileStreamer.ClearCache();
        }
    }
}
```

### 7.3 加载缓慢

```csharp
// 优化加载速度
public class LoadOptimizer : MonoBehaviour
{
    public void OptimizeLoading()
    {
        // 1. 使用KTX2格式
        bool useKTX2 = true;
        
        // 2. 增加并发加载
        int maxConcurrentLoads = 8;
        
        // 3. 预加载关键瓦片
        PreloadCriticalTiles();
        
        // 4. 使用SSD存储
        // (操作系统级别)
    }

    private void PreloadCriticalTiles()
    {
        // 场景启动时预加载基础z14-z16瓦片
        for (int z = 14; z <= 16; z++)
        {
            // 预加载逻辑
        }
    }
}
```

---

## 8. 阶段性验收标准

### 第1阶段：单ROI测试

```
□ 功能验收
  □ 单个z19-z20 ROI完整加载
  □ 瓦片显示无黑块或错误
  □ 坐标对齐正确

□ 性能验收（GTX 1060基准）
  ✓ 帧率 ≥ 60 FPS
  ✓ 显存占用 ≤ 256 MB
  ✓ CPU占用 ≤ 20%
  ✓ 无内存泄漏（运行1小时）

□ 优化验收
  □ 已启用Texture Streaming
  □ 已启用KTX2格式
  □ LRU缓存工作正常
```

### 第2阶段：多ROI扩展

```
□ 功能验收
  □ 7个ROI可切换加载
  □ z14-z18基础瓦片覆盖全矿区
  □ 优先级加载正确

□ 性能验收（相同硬件）
  ✓ 帧率 ≥ 45 FPS (降低10%)
  ✓ 显存占用 ≤ 512 MB
  ✓ CPU占用 ≤ 30%
  ✓ 多ROI切换无卡顿

□ 流式加载验收
  □ 相机移动时平滑加载
  □ 离屏ROI自动卸载
  □ 内存稳定（无泄漏）
```

### 第3阶段：全域优化

```
□ 功能验收
  □ z14-z20所有等级可用
  □ 全矿区42×48km覆盖
  □ 建筑群高精度细节可用

□ 性能验收（相同硬件）
  ✓ 帧率 ≥ 30 FPS (生产环境最低要求)
  ✓ 显存占用 ≤ 1024 MB
  ✓ CPU占用 ≤ 50%
  ✓ 运行2小时无崩溃

□ 用户体验验收
  □ 相机移动响应及时
  □ 瓦片加载无明显卡顿
  □ 视觉质量满足要求
  □ 操作流畅稳定
```

---

## 9. 优化检查清单

```
□ 纹理优化
  □ ☑ Stream Textures已启用
  □ Pool Size设置合理
  □ 瓦片PNG使用CRUNCH压缩
  □ 瓦片已转换为KTX2（可选但推荐）

□ 显存优化
  □ Cache Memory MB根据GPU调整
  □ LRU缓存自动驱逐工作正常
  □ 监控脚本显示内存健康

□ LOD优化
  □ nearZoom/midZoom/farZoom参数合理
  □ radius参数根据性能调整
  □ 不同硬件配置不同参数

□ 并发优化
  □ Max Concurrent Loads ∈ [2, 16]
  □ 根据硬件选择合适值
  □ 运行时动态监测

□ 性能监控
  □ Profiler集成到项目
  □ 运行性能基准测试
  □ 记录baseline数据

□ 测试验收
  □ 单ROI达到性能目标
  □ 多ROI达到性能目标
  □ 全域场景性能可接受
```

---

## 参考资源

- **Unity Profiler文档**：https://docs.unity3d.com/Manual/Profiler.html
- **Texture Streaming**：https://docs.unity3d.com/Manual/StreamingTexturesInfo.html
- **性能优化最佳实践**：https://docs.unity3d.com/Manual/BestPracticeGuides.html
- **KTX2最优设置**：https://github.khronos.org/KTX-Software/
